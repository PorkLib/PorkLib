/*
 * Adapted from the Wizardry License
 *
 * Copyright (c) 2018-2018 DaPorkchop_ and contributors
 *
 * Permission is hereby granted to any persons and/or organizations using this software to copy, modify, merge, publish, and distribute it. Said persons and/or organizations are not allowed to use the software or any derivatives of the work for commercial use or any other means to generate income, nor are they allowed to claim this software as their own.
 *
 * The persons and/or organizations are also disallowed from sub-licensing and/or trademarking this software without explicit permission from DaPorkchop_.
 *
 * Any persons and/or organizations using this software must disclose their source code and have it publicly available, include this license, provide sufficient credit to the original authors of the project (IE: DaPorkchop_), as well as provide a link to the original project.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

package net.daporkchop.lib.primitive.map.concurrent.treehash;

import net.daporkchop.lib.primitive.lambda.consumer._P1_Consumer;
import net.daporkchop.lib.primitive.lambda.consumer._P2_Consumer;
import net.daporkchop.lib.primitive.lambda.consumer.bi._P1__P2_Consumer;
import net.daporkchop.lib.primitive.lambda.function._P1_ToIntegerFunction;
import net.daporkchop.lib.primitive.lambda.function._P1_ToLongFunction;
import net.daporkchop.lib.primitive.iterator.concurrent._P1_ConcurrentIterator;
import net.daporkchop.lib.primitive.iterator.concurrent._P2_ConcurrentIterator;
import net.daporkchop.lib.primitive.iterator.concurrent._P1__P2_ConcurrentIterator;
import net.daporkchop.lib.primitive.map._P1__P2_Map;
import net.daporkchop.lib.primitive.tuple._P1__P2_Tuple;
import net.daporkchop.lib.primitive.tuple._P1__P2_ImmutableTuple;
import net.daporkchop.lib.primitive.tuple._P1__P2_MutableTuple;
import net.daporkchop.lib.primitiveutil.IteratorCompleteException;
import net.daporkchop.lib.primitiveutil.VoidFunction;

import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import lombok.*;

/**
 * A tree hash map, using a key type of _p1_ and a value type of _p2_.
 * Designed to be highly concurrent, it should operate well with as many as 256
 * threads at the same time.
 * <p>
 * DO NOT EDIT BY HAND! THIS FILE IS SCRIPT-GENERATED!
 *
 * @author DaPorkchop_
 */
public class _P1__P2_ConcurrentTreeHashMap_GH_ implements _P1__P2_Map_GHI_    {
    final AtomicInteger size = new AtomicInteger(0);

    private final _P1__P2_SubEntry[] entries = new _P1__P2_SubEntry[256];
    private final _P1_ToIntegerFunction keyHash;
    final _P1_ToLongFunction subKeyHash;
    final int subHashLength;

    public _P1__P2_ConcurrentTreeHashMap()    {
        this(null, null);
    }

    public _P1__P2_ConcurrentTreeHashMap(_P1_ToIntegerFunction keyHash, _P1_ToLongFunction subKeyHash)    {
        this(keyHash, subKeyHash, _p1b_);
    }

    public _P1__P2_ConcurrentTreeHashMap(_P1_ToIntegerFunction keyHash, _P1_ToLongFunction subKeyHash, int subHashLength)    {
        if (subHashLength < 0 || subHashLength > 8)  {
            throw new IllegalArgumentException("subHashLength must be in range 0-8 (given: " + subHashLength + ")");
        }

        if (keyHash == null)    {
            this.keyHash = in -> {
                _p1hf_
            };
        } else {
            this.keyHash = keyHash;
        }
        if (subKeyHash == null)    {
            this.subKeyHash = in -> {
                _p1lhf_
            };
            this.subHashLength = _p1b_;
        } else {
            this.subKeyHash = subKeyHash;
            this.subHashLength = subHashLength;
        }
    }

    @Override
    public _p2_ get(_p1_ key)   {
        _P1__P2_SubEntry_GHI_ entry = this.getSubentry(this.keyHash.apply(key) & 0xFF, false);
        if (entry == null)  {
            return _p2e_;
        } else {
            return_GVC_ entry.get(key);
        }
    }

    @Override
    public _p2_ put(_p1_ key, _p2_ value)   {
        _P1__P2_SubEntry_GHI_ entry = this.getSubentry(this.keyHash.apply(key) & 0xFF, true);
        return_GVC_ entry.put(key, value);
    }

    @Override
    public _p2_ remove(_p1_ key)    {
        int hash = this.keyHash.apply(key) & 0xFF;
        _P1__P2_SubEntry_GHI_ entry = this.getSubentry(hash, false);
        if (entry == null)  {
            return _p2e_;
        } else {
            _p2_ val =_GVC_ entry.remove(key);
            if (entry.size.get() == 0)  {
                this.entries[hash] = null;
            }
            return val;
        }
    }

    @Override
    public boolean containsKey(_p1_ key)    {
        _P1__P2_SubEntry_GHI_ entry = this.getSubentry(this.keyHash.apply(key) & 0xFF, false);
        if (entry == null)  {
            return false;
        } else {
            return entry.containsKey(key);
        }
    }

    @Override
    public boolean containsValue(_p2_ value)    {
        throw new UnsupportedOperationException("containsValue on ConcurrentTreeHashMap!");
    }

    @Override
    public void clear() {
        synchronized (this.entries) {
            for (int i = 0; i < 256; i++) {
                _P1__P2_SubEntry_GHI_ entry = this.entries[i];
                if (entry != null)  {
                    entry.clear();
                    this.entries[i] = null;
                }
            }
        }
    }

    @Override
    public int getSize()    {
        return this.size.get();
    }

    @Override
    public void forEachKey(_P1_Consumer_GK_ consumer)   {
        for (int i = 0; i < 256; i++) {
            _P1__P2_SubEntry_GHI_ entry = this.getSubentry(i, false);
            if (entry != null)  {
                entry.forEachKey(consumer);
            }
        }
    }

    @Override
    public void forEachValue(_P2_Consumer_GV_ consumer) {
        for (int i = 0; i < 256; i++) {
            _P1__P2_SubEntry_GHI_ entry = this.getSubentry(i, false);
            if (entry != null)  {
                entry.forEachValue(consumer);
            }
        }
    }

    @Override
    public void forEachEntry(_P1__P2_Consumer_GHI_ consumer) {
        for (int i = 0; i < 256; i++) {
            _P1__P2_SubEntry_GHI_ entry = this.getSubentry(i, false);
            if (entry != null)  {
                entry.forEachEntry(consumer);
            }
        }
    }

    public void forEachEntry(_P1__P2_Consumer_GHI_ consumer, VoidFunction complete) {
        for (int i = 0; i < 256; i++) {
            _P1__P2_SubEntry_GHI_ entry = this.getSubentry(i, false);
            if (entry != null)  {
                entry.forEachEntry(consumer);
            }
        }
        complete.run();
    }

    @Override
    public _P1_ConcurrentIterator_GK_ keyIterator()   {
        return new _P1_ConcurrentIterator_GK_()  {
            private final _P1__P2_ConcurrentTreeHashMap this_ = _P1__P2_ConcurrentTreeHashMap.this;
            //private final ReentrantLock lock = new ReentrantLock();
            private final ThreadLocal<ThreadState> tl = ThreadLocal.withInitial(() -> new ThreadState(this, this.this_));
            private final AtomicInteger sectorOffset = new AtomicInteger(0);
            private final AtomicReference<_P1__P2_SubEntry_GHI_.Sector> currSector = new AtomicReference(null);
            private final AtomicBoolean hasNextSub = new AtomicBoolean(true);
            private volatile boolean hasNext = true;
            private volatile int subEntryIndex = 0;
            private volatile _p1_ next;
            private volatile _P1__P2_SubEntry_GHI_ entry;

            {
                this.nextSub();
                this.findNextValue();
            }

            @Override
            public boolean hasNext()    {
                return this.hasNext;
            }

            @Override
            public _p1_ get()   {
                ThreadState state = this.tl.get();
                if (state.entry == null)    {
                    throw new IllegalStateException();
                } else {
                    return state.key;
                }
            }

            @Override
            public synchronized _p1_ advance()   {
                if (!this.hasNext())    {
                    throw new IteratorCompleteException();
                }
                ThreadState state = this.tl.get();
                _p1_ current = state.key = this.next;
                state.entry = this.entry;
                this.findNextValue();
                return current;
            }

            @Override
            public void remove(){
                this.tl.get().remove();
            }

            private void nextSub()   {
                if (this.entry != null) {
                    this.entry.endConcurrentIterate();
                }
                while (this.subEntryIndex < 256)    {
                    _P1__P2_SubEntry_GHI_ entry = getSubentry(this.subEntryIndex++, false);
                    if (entry != null)  {
                        this.entry = entry;
                        this.hasNextSub.set(true);
                        this.currSector.set(null);
                        this.sectorOffset.set(-1);
                        this.entry.beginConcurrentIterate();
                        return;
                    }
                }
                this.hasNext = false;
            }

            private void findNextValue()    {
                while (this.hasNext) {
                    this.next = this.entry.advanceKey(this.currSector, this.sectorOffset, this.hasNextSub);
                    if (this.hasNextSub.get()) {
                        //new value was gotten
                        return;
                    } else {
                        //move to next subentry
                        this.nextSub();
                    }
                }
                if (this.entry.isLocked())  {
                    this.entry.endConcurrentIterate();
                }
            }

            class ThreadState   {
                public _p1_ key;
                public _P1__P2_SubEntry entry;
                private final _P1_ConcurrentIterator_GK_ this_;
                private final _P1__P2_ConcurrentTreeHashMap this__;

                public ThreadState(_P1_ConcurrentIterator_GK_ this_, _P1__P2_ConcurrentTreeHashMap this__)  {
                    this.this_ = this_;
                    this.this__ = this__;
                }

                public void remove()    {
                    if (this.this_.hasNext())    {
                        this.entry.removeNonBlocking_BeReallyCarefulWithThis(this.key);
                    } else {
                        this.this__.remove(this.key);
                    }
                }
            }
        };
    }

    @Override
    public _P2_ConcurrentIterator_GV_ valueIterator() {
        return new _P2_ConcurrentIterator_GV_()  {
            private final _P1__P2_ConcurrentTreeHashMap this_ = _P1__P2_ConcurrentTreeHashMap.this;
            //private final ReentrantLock lock = new ReentrantLock();
            private final ThreadLocal<ThreadState> tl = ThreadLocal.withInitial(() -> new ThreadState(this, this.this_));
            private final AtomicInteger sectorOffset = new AtomicInteger(0);
            private final AtomicReference<_P1__P2_SubEntry_GHI_.Sector> currSector = new AtomicReference(null);
            private final AtomicBoolean hasNextSub = new AtomicBoolean(true);
            private final _P1__P2_MutableTuple_GHI_ next = new _P1__P2_MutableTuple_GHI_();
            private volatile boolean hasNext = true;
            private volatile int subEntryIndex = 0;
            private volatile _P1__P2_SubEntry_GHI_ entry;

            {
                this.nextSub();
                this.findNextValue();
            }

            @Override
            public boolean hasNext()    {
                return this.hasNext;
            }

            @Override
            public _p2_ get()   {
                ThreadState state = this.tl.get();
                if (state.entry == null)    {
                    throw new IllegalStateException();
                } else {
                    return state.val;
                }
            }

            @Override
            public synchronized _p2_ advance()   {
                if (!this.hasNext())    {
                    throw new IteratorCompleteException();
                }
                ThreadState state = this.tl.get();
                state.key = this.next.k;
                _p2_ current = state.val = this.next.v;
                state.entry = this.entry;
                this.findNextValue();
                return current;
            }

            @Override
            public void remove(){
                this.tl.get().remove();
            }

            private void nextSub()   {
                if (this.entry != null) {
                    this.entry.endConcurrentIterate();
                }
                while (this.subEntryIndex < 256)    {
                    _P1__P2_SubEntry_GHI_ entry = getSubentry(this.subEntryIndex++, false);
                    if (entry != null)  {
                        this.entry = entry;
                        this.hasNextSub.set(true);
                        this.currSector.set(null);
                        this.sectorOffset.set(-1);
                        this.entry.beginConcurrentIterate();
                        return;
                    }
                }
                this.hasNext = false;
            }

            private void findNextValue()    {
                while (this.hasNext) {
                    this.entry.advanceEntry(this.currSector, this.sectorOffset, this.hasNextSub, this.next);
                    if (this.hasNextSub.get()) {
                        //new value was gotten
                        return;
                    } else {
                        //move to next subentry
                        this.nextSub();
                    }
                }
                if (this.entry.isLocked())  {
                    this.entry.endConcurrentIterate();
                }
            }

            class ThreadState   {
                public _p1_ key;
                public _p2_ val;
                public _P1__P2_SubEntry entry;
                private final _P2_ConcurrentIterator_GV_ this_;
                private final _P1__P2_ConcurrentTreeHashMap this__;

                public ThreadState(_P2_ConcurrentIterator_GV_ this_, _P1__P2_ConcurrentTreeHashMap this__)  {
                    this.this_ = this_;
                    this.this__ = this__;
                }

                public void remove()    {
                    if (this.entry != null)    {
                        if (this.this_.hasNext())    {
                            this.entry.removeNonBlocking_BeReallyCarefulWithThis(this.key);
                        } else {
                            this.this__.remove(this.key);
                        }
                    }
                }
            }
        };
    }

    @Override
    public _P1__P2_ConcurrentIterator_GHI_ entryIterator() {
        return new _P1__P2_ConcurrentIterator_GHI_()  {
            private final _P1__P2_ConcurrentTreeHashMap this_ = _P1__P2_ConcurrentTreeHashMap.this;
            //private final ReentrantLock lock = new ReentrantLock();
            private final ThreadLocal<ThreadState> tl = ThreadLocal.withInitial(() -> new ThreadState(this, this.this_));
            private final AtomicInteger sectorOffset = new AtomicInteger(0);
            private final AtomicReference<_P1__P2_SubEntry_GHI_.Sector> currSector = new AtomicReference(null);
            private final AtomicBoolean hasNextSub = new AtomicBoolean(true);
            private final _P1__P2_MutableTuple_GHI_ next = new _P1__P2_MutableTuple_GHI_();
            private volatile boolean hasNext = true;
            private volatile int subEntryIndex = 0;
            private volatile _P1__P2_SubEntry_GHI_ entry;

            {
                this.nextSub();
                this.findNextValue();
            }

            @Override
            public boolean hasNext()    {
                return this.hasNext;
            }

            @Override
            public _P1__P2_Tuple_GHI_ get()   {
                ThreadState state = this.tl.get();
                if (state.entry == null)    {
                    throw new IllegalStateException();
                } else {
                    return state.tuple;
                }
            }

            @Override
            public synchronized _P1__P2_Tuple_GHI_ advance()   {
                if (!this.hasNext())    {
                    throw new IteratorCompleteException();
                }
                ThreadState state = this.tl.get();
                _P1__P2_Tuple_GHI_ current = state.tuple = new _P1__P2_MutableTuple_GHI_(this.next.k, this.next.v);
                state.entry = this.entry;
                this.findNextValue();
                return current;
            }

            @Override
            public void remove(){
                this.tl.get().remove();
            }

            private void nextSub()   {
                if (this.entry != null) {
                    this.entry.endConcurrentIterate();
                }
                while (this.subEntryIndex < 256)    {
                    _P1__P2_SubEntry_GHI_ entry = getSubentry(this.subEntryIndex++, false);
                    if (entry != null)  {
                        this.entry = entry;
                        this.hasNextSub.set(true);
                        this.currSector.set(null);
                        this.sectorOffset.set(-1);
                        this.entry.beginConcurrentIterate();
                        return;
                    }
                }
                this.hasNext = false;
            }

            private void findNextValue()    {
                while (this.hasNext) {
                    this.entry.advanceEntry(this.currSector, this.sectorOffset, this.hasNextSub, this.next);
                    if (this.hasNextSub.get()) {
                        //new value was gotten
                        return;
                    } else {
                        //move to next subentry
                        this.nextSub();
                    }
                }
                if (this.entry.isLocked())  {
                    this.entry.endConcurrentIterate();
                }
            }

            class ThreadState   {
                public _P1__P2_Tuple_GHI_ tuple;
                public _P1__P2_SubEntry entry;
                private final _P1__P2_ConcurrentIterator_GHI_ this_;
                private final _P1__P2_ConcurrentTreeHashMap this__;

                public ThreadState(_P1__P2_ConcurrentIterator_GHI_ this_, _P1__P2_ConcurrentTreeHashMap this__)  {
                    this.this_ = this_;
                    this.this__ = this__;
                }

                public void remove()    {
                    if (this.tuple != null)    {
                        if (this.this_.hasNext())    {
                            this.entry.removeNonBlocking_BeReallyCarefulWithThis(this.tuple.getK());
                        } else {
                            this.this__.remove(this.tuple.getK());
                        }
                    }
                }
            }
        };
    }

    /**
     * A fast iterator over entries.
     * The tuple returned by this iterator is reused, so don't cache it!
     */
    public _P1__P2_ConcurrentIterator_GHI_ fastEntryIterator() {
        return new _P1__P2_ConcurrentIterator_GHI_()  {
            private final _P1__P2_ConcurrentTreeHashMap this_ = _P1__P2_ConcurrentTreeHashMap.this;
            //private final ReentrantLock lock = new ReentrantLock();
            private final ThreadLocal<ThreadState> tl = ThreadLocal.withInitial(() -> new ThreadState(this, this.this_));
            private final AtomicInteger sectorOffset = new AtomicInteger(0);
            private final AtomicReference<_P1__P2_SubEntry_GHI_.Sector> currSector = new AtomicReference(null);
            private final AtomicBoolean hasNextSub = new AtomicBoolean(true);
            private volatile _P1__P2_MutableTuple_GHI_ next = new _P1__P2_MutableTuple_GHI_(_p1e_, _p2e_);
            private volatile boolean hasNext = true;
            private volatile int subEntryIndex = 0;
            private volatile _P1__P2_SubEntry_GHI_ entry;

            {
                this.nextSub();
                this.findNextValue();
            }

            @Override
            public boolean hasNext()    {
                return this.hasNext;
            }

            @Override
            public _P1__P2_MutableTuple_GHI_ get()   {
                ThreadState state = this.tl.get();
                if (state.entry == null)    {
                    throw new IllegalStateException();
                } else {
                    return state.tuple;
                }
            }

            @Override
            public synchronized _P1__P2_MutableTuple_GHI_ advance()   {
                if (!this.hasNext())    {
                    throw new IteratorCompleteException();
                }
                ThreadState state = this.tl.get();
                _P1__P2_MutableTuple_GHI_ a = state.tuple;
                state.tuple = this.next;
                this.next = a;
                state.entry = this.entry;
                this.findNextValue();
                return state.tuple;
            }

            @Override
            public void remove(){
                this.tl.get().remove();
            }

            private void nextSub()   {
                if (this.entry != null) {
                    this.entry.endConcurrentIterate();
                }
                while (this.subEntryIndex < 256)    {
                    _P1__P2_SubEntry_GHI_ entry = getSubentry(this.subEntryIndex++, false);
                    if (entry != null)  {
                        this.entry = entry;
                        this.hasNextSub.set(true);
                        this.currSector.set(null);
                        this.sectorOffset.set(-1);
                        this.entry.beginConcurrentIterate();
                        return;
                    }
                }
                this.hasNext = false;
            }

            private void findNextValue()    {
                while (this.hasNext) {
                    this.entry.advanceEntry(this.currSector, this.sectorOffset, this.hasNextSub, this.next);
                    if (this.hasNextSub.get()) {
                        //new value was gotten
                        return;
                    } else {
                        //move to next subentry
                        this.nextSub();
                    }
                }
                if (this.entry.isLocked())  {
                    this.entry.endConcurrentIterate();
                }
            }

            class ThreadState   {
                public _P1__P2_MutableTuple_GHI_ tuple = new _P1__P2_MutableTuple_GHI_(_p1e_, _p2e_);
                public _P1__P2_SubEntry entry;
                private final _P1__P2_ConcurrentIterator_GHI_ this_;
                private final _P1__P2_ConcurrentTreeHashMap this__;

                public ThreadState(_P1__P2_ConcurrentIterator_GHI_ this_, _P1__P2_ConcurrentTreeHashMap this__)  {
                    this.this_ = this_;
                    this.this__ = this__;
                }

                public void remove()    {
                    if (this.tuple != null)    {
                        if (this.this_.hasNext())    {
                            this.entry.removeNonBlocking_BeReallyCarefulWithThis(this.tuple.k);
                        } else {
                            this.this__.remove(this.tuple.k);
                        }
                    }
                }
            }
        };
    }

    private _P1__P2_SubEntry_GHI_ getSubentry(int index, boolean create)    {
        assert index == (index & 0xFF);

        synchronized (this.entries) {
            _P1__P2_SubEntry_GHI_ entry = (_P1__P2_SubEntry_GHI_) this.entries[index];
            if (entry == null && create)    {
                this.entries[index] = entry = new _P1__P2_SubEntry_GHI_(this);
            }
            return entry;
        }
    }
}
